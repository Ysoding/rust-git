use std::{
    fs::File,
    io::Write,
    path::{Path, PathBuf},
};

use anyhow::Result;

use crate::{
    kvlm_parse, kvlm_serialize, object_find, object_write, ref_list_flat, repo_dir, repo_file,
    repo_find, show_ref_print, Kvlm, Object, Repository,
};

#[derive(Default)]
pub struct Tag {
    pub kvlm: Kvlm,
}

impl Tag {
    pub fn deserialize(data: &[u8]) -> Self {
        let kvlm = kvlm_parse(data);
        Self { kvlm }
    }
}

impl Object for Tag {
    fn fmt(&self) -> &'static [u8] {
        b"tag"
    }

    fn serialize(&self) -> Vec<u8> {
        kvlm_serialize(&self.kvlm)
    }

    fn as_any(&self) -> &dyn std::any::Any {
        self
    }
}

pub fn tag(create_tag_object: bool, name: Option<String>, obj: &str) -> Result<()> {
    let repo = repo_find(Path::new("."), true)?.unwrap();
    if let Some(name) = name {
        tag_create(&repo, &name, obj, create_tag_object)?;
    } else {
        let refs = ref_list_flat(
            &repo,
            Some(repo_dir(&repo, PathBuf::from("refs/tags"), false)?.unwrap()),
            None,
        )?;
        show_ref_print(&refs, false);
    }
    Ok(())
}

fn tag_create(repo: &Repository, name: &str, obj_ref: &str, create_tag_object: bool) -> Result<()> {
    let sha = object_find(repo, obj_ref, None, true)?.unwrap();

    if create_tag_object {
        let mut tag = Tag::default();
        tag.kvlm
            .insert(Some(b"object".to_vec()), vec![sha.clone().into_bytes()]);
        tag.kvlm
            .insert(Some(b"type".to_vec()), vec![b"commit".to_vec()]);
        tag.kvlm
            .insert(Some(b"tag".to_vec()), vec![name.as_bytes().to_vec()]);
        tag.kvlm.insert(
            Some(b"tagger".to_vec()),
            vec![b"Wyag <wyag@example.com>".to_vec()],
        );
        tag.kvlm
            .insert(None, vec![b"A tag generated by wyag\n".to_vec()]);
        let tag_sha = object_write(&tag, Some(repo))?;
        ref_create(repo, &format!("tags/{}", name), &tag_sha)?;
    } else {
        ref_create(repo, &format!("tags/{}", name), &sha)?;
    }
    Ok(())
}

pub fn ref_create(repo: &Repository, ref_name: &str, sha: &str) -> Result<()> {
    let path = repo_file(repo, PathBuf::from(format!("refs/{}", ref_name)), false)?;
    let mut f = File::create(&path)?;
    f.write_all(format!("{}\n", sha).as_bytes())?;
    Ok(())
}
